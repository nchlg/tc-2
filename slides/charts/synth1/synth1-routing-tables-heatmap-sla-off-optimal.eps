%!PS-Adobe-2.0 EPSF-2.0
%%Title: synth1-routing-tables-heatmap-sla-off-optimal.eps
%%Creator: gnuplot 5.0 patchlevel 3
%%CreationDate: Mon Oct 31 10:54:38 2016
%%DocumentFonts: (atend)
%%BoundingBox: 50 50 410 302
%%EndComments
%%BeginProlog
/gnudict 256 dict def
gnudict begin
%
% The following true/false flags may be edited by hand if desired.
% The unit line width and grayscale image gamma correction may also be changed.
%
/Color true def
/Blacktext false def
/Solid false def
/Dashlength 1 def
/Landscape false def
/Level1 false def
/Level3 false def
/Rounded false def
/ClipToBoundingBox false def
/SuppressPDFMark false def
/TransparentPatterns false def
/gnulinewidth 5.000 def
/userlinewidth gnulinewidth def
/Gamma 1.0 def
/BackgroundColor {-1.000 -1.000 -1.000} def
%
/vshift -66 def
/dl1 {
  10.0 Dashlength userlinewidth gnulinewidth div mul mul mul
  Rounded { currentlinewidth 0.75 mul sub dup 0 le { pop 0.01 } if } if
} def
/dl2 {
  10.0 Dashlength userlinewidth gnulinewidth div mul mul mul
  Rounded { currentlinewidth 0.75 mul add } if
} def
/hpt_ 31.5 def
/vpt_ 31.5 def
/hpt hpt_ def
/vpt vpt_ def
/doclip {
  ClipToBoundingBox {
    newpath 50 50 moveto 410 50 lineto 410 302 lineto 50 302 lineto closepath
    clip
  } if
} def
%
% Gnuplot Prolog Version 5.1 (Oct 2015)
%
%/SuppressPDFMark true def
%
/M {moveto} bind def
/L {lineto} bind def
/R {rmoveto} bind def
/V {rlineto} bind def
/N {newpath moveto} bind def
/Z {closepath} bind def
/C {setrgbcolor} bind def
/f {rlineto fill} bind def
/g {setgray} bind def
/Gshow {show} def   % May be redefined later in the file to support UTF-8
/vpt2 vpt 2 mul def
/hpt2 hpt 2 mul def
/Lshow {currentpoint stroke M 0 vshift R 
	Blacktext {gsave 0 setgray textshow grestore} {textshow} ifelse} def
/Rshow {currentpoint stroke M dup stringwidth pop neg vshift R
	Blacktext {gsave 0 setgray textshow grestore} {textshow} ifelse} def
/Cshow {currentpoint stroke M dup stringwidth pop -2 div vshift R 
	Blacktext {gsave 0 setgray textshow grestore} {textshow} ifelse} def
/UP {dup vpt_ mul /vpt exch def hpt_ mul /hpt exch def
  /hpt2 hpt 2 mul def /vpt2 vpt 2 mul def} def
/DL {Color {setrgbcolor Solid {pop []} if 0 setdash}
 {pop pop pop 0 setgray Solid {pop []} if 0 setdash} ifelse} def
/BL {stroke userlinewidth 2 mul setlinewidth
	Rounded {1 setlinejoin 1 setlinecap} if} def
/AL {stroke userlinewidth 2 div setlinewidth
	Rounded {1 setlinejoin 1 setlinecap} if} def
/UL {dup gnulinewidth mul /userlinewidth exch def
	dup 1 lt {pop 1} if 10 mul /udl exch def} def
/PL {stroke userlinewidth setlinewidth
	Rounded {1 setlinejoin 1 setlinecap} if} def
3.8 setmiterlimit
% Classic Line colors (version 5.0)
/LCw {1 1 1} def
/LCb {0 0 0} def
/LCa {0 0 0} def
/LC0 {1 0 0} def
/LC1 {0 1 0} def
/LC2 {0 0 1} def
/LC3 {1 0 1} def
/LC4 {0 1 1} def
/LC5 {1 1 0} def
/LC6 {0 0 0} def
/LC7 {1 0.3 0} def
/LC8 {0.5 0.5 0.5} def
% Default dash patterns (version 5.0)
/LTB {BL [] LCb DL} def
/LTw {PL [] 1 setgray} def
/LTb {PL [] LCb DL} def
/LTa {AL [1 udl mul 2 udl mul] 0 setdash LCa setrgbcolor} def
/LT0 {PL [] LC0 DL} def
/LT1 {PL [2 dl1 3 dl2] LC1 DL} def
/LT2 {PL [1 dl1 1.5 dl2] LC2 DL} def
/LT3 {PL [6 dl1 2 dl2 1 dl1 2 dl2] LC3 DL} def
/LT4 {PL [1 dl1 2 dl2 6 dl1 2 dl2 1 dl1 2 dl2] LC4 DL} def
/LT5 {PL [4 dl1 2 dl2] LC5 DL} def
/LT6 {PL [1.5 dl1 1.5 dl2 1.5 dl1 1.5 dl2 1.5 dl1 6 dl2] LC6 DL} def
/LT7 {PL [3 dl1 3 dl2 1 dl1 3 dl2] LC7 DL} def
/LT8 {PL [2 dl1 2 dl2 2 dl1 6 dl2] LC8 DL} def
/SL {[] 0 setdash} def
/Pnt {stroke [] 0 setdash gsave 1 setlinecap M 0 0 V stroke grestore} def
/Dia {stroke [] 0 setdash 2 copy vpt add M
  hpt neg vpt neg V hpt vpt neg V
  hpt vpt V hpt neg vpt V closepath stroke
  Pnt} def
/Pls {stroke [] 0 setdash vpt sub M 0 vpt2 V
  currentpoint stroke M
  hpt neg vpt neg R hpt2 0 V stroke
 } def
/Box {stroke [] 0 setdash 2 copy exch hpt sub exch vpt add M
  0 vpt2 neg V hpt2 0 V 0 vpt2 V
  hpt2 neg 0 V closepath stroke
  Pnt} def
/Crs {stroke [] 0 setdash exch hpt sub exch vpt add M
  hpt2 vpt2 neg V currentpoint stroke M
  hpt2 neg 0 R hpt2 vpt2 V stroke} def
/TriU {stroke [] 0 setdash 2 copy vpt 1.12 mul add M
  hpt neg vpt -1.62 mul V
  hpt 2 mul 0 V
  hpt neg vpt 1.62 mul V closepath stroke
  Pnt} def
/Star {2 copy Pls Crs} def
/BoxF {stroke [] 0 setdash exch hpt sub exch vpt add M
  0 vpt2 neg V hpt2 0 V 0 vpt2 V
  hpt2 neg 0 V closepath fill} def
/TriUF {stroke [] 0 setdash vpt 1.12 mul add M
  hpt neg vpt -1.62 mul V
  hpt 2 mul 0 V
  hpt neg vpt 1.62 mul V closepath fill} def
/TriD {stroke [] 0 setdash 2 copy vpt 1.12 mul sub M
  hpt neg vpt 1.62 mul V
  hpt 2 mul 0 V
  hpt neg vpt -1.62 mul V closepath stroke
  Pnt} def
/TriDF {stroke [] 0 setdash vpt 1.12 mul sub M
  hpt neg vpt 1.62 mul V
  hpt 2 mul 0 V
  hpt neg vpt -1.62 mul V closepath fill} def
/DiaF {stroke [] 0 setdash vpt add M
  hpt neg vpt neg V hpt vpt neg V
  hpt vpt V hpt neg vpt V closepath fill} def
/Pent {stroke [] 0 setdash 2 copy gsave
  translate 0 hpt M 4 {72 rotate 0 hpt L} repeat
  closepath stroke grestore Pnt} def
/PentF {stroke [] 0 setdash gsave
  translate 0 hpt M 4 {72 rotate 0 hpt L} repeat
  closepath fill grestore} def
/Circle {stroke [] 0 setdash 2 copy
  hpt 0 360 arc stroke Pnt} def
/CircleF {stroke [] 0 setdash hpt 0 360 arc fill} def
/C0 {BL [] 0 setdash 2 copy moveto vpt 90 450 arc} bind def
/C1 {BL [] 0 setdash 2 copy moveto
	2 copy vpt 0 90 arc closepath fill
	vpt 0 360 arc closepath} bind def
/C2 {BL [] 0 setdash 2 copy moveto
	2 copy vpt 90 180 arc closepath fill
	vpt 0 360 arc closepath} bind def
/C3 {BL [] 0 setdash 2 copy moveto
	2 copy vpt 0 180 arc closepath fill
	vpt 0 360 arc closepath} bind def
/C4 {BL [] 0 setdash 2 copy moveto
	2 copy vpt 180 270 arc closepath fill
	vpt 0 360 arc closepath} bind def
/C5 {BL [] 0 setdash 2 copy moveto
	2 copy vpt 0 90 arc
	2 copy moveto
	2 copy vpt 180 270 arc closepath fill
	vpt 0 360 arc} bind def
/C6 {BL [] 0 setdash 2 copy moveto
	2 copy vpt 90 270 arc closepath fill
	vpt 0 360 arc closepath} bind def
/C7 {BL [] 0 setdash 2 copy moveto
	2 copy vpt 0 270 arc closepath fill
	vpt 0 360 arc closepath} bind def
/C8 {BL [] 0 setdash 2 copy moveto
	2 copy vpt 270 360 arc closepath fill
	vpt 0 360 arc closepath} bind def
/C9 {BL [] 0 setdash 2 copy moveto
	2 copy vpt 270 450 arc closepath fill
	vpt 0 360 arc closepath} bind def
/C10 {BL [] 0 setdash 2 copy 2 copy moveto vpt 270 360 arc closepath fill
	2 copy moveto
	2 copy vpt 90 180 arc closepath fill
	vpt 0 360 arc closepath} bind def
/C11 {BL [] 0 setdash 2 copy moveto
	2 copy vpt 0 180 arc closepath fill
	2 copy moveto
	2 copy vpt 270 360 arc closepath fill
	vpt 0 360 arc closepath} bind def
/C12 {BL [] 0 setdash 2 copy moveto
	2 copy vpt 180 360 arc closepath fill
	vpt 0 360 arc closepath} bind def
/C13 {BL [] 0 setdash 2 copy moveto
	2 copy vpt 0 90 arc closepath fill
	2 copy moveto
	2 copy vpt 180 360 arc closepath fill
	vpt 0 360 arc closepath} bind def
/C14 {BL [] 0 setdash 2 copy moveto
	2 copy vpt 90 360 arc closepath fill
	vpt 0 360 arc} bind def
/C15 {BL [] 0 setdash 2 copy vpt 0 360 arc closepath fill
	vpt 0 360 arc closepath} bind def
/Rec {newpath 4 2 roll moveto 1 index 0 rlineto 0 exch rlineto
	neg 0 rlineto closepath} bind def
/Square {dup Rec} bind def
/Bsquare {vpt sub exch vpt sub exch vpt2 Square} bind def
/S0 {BL [] 0 setdash 2 copy moveto 0 vpt rlineto BL Bsquare} bind def
/S1 {BL [] 0 setdash 2 copy vpt Square fill Bsquare} bind def
/S2 {BL [] 0 setdash 2 copy exch vpt sub exch vpt Square fill Bsquare} bind def
/S3 {BL [] 0 setdash 2 copy exch vpt sub exch vpt2 vpt Rec fill Bsquare} bind def
/S4 {BL [] 0 setdash 2 copy exch vpt sub exch vpt sub vpt Square fill Bsquare} bind def
/S5 {BL [] 0 setdash 2 copy 2 copy vpt Square fill
	exch vpt sub exch vpt sub vpt Square fill Bsquare} bind def
/S6 {BL [] 0 setdash 2 copy exch vpt sub exch vpt sub vpt vpt2 Rec fill Bsquare} bind def
/S7 {BL [] 0 setdash 2 copy exch vpt sub exch vpt sub vpt vpt2 Rec fill
	2 copy vpt Square fill Bsquare} bind def
/S8 {BL [] 0 setdash 2 copy vpt sub vpt Square fill Bsquare} bind def
/S9 {BL [] 0 setdash 2 copy vpt sub vpt vpt2 Rec fill Bsquare} bind def
/S10 {BL [] 0 setdash 2 copy vpt sub vpt Square fill 2 copy exch vpt sub exch vpt Square fill
	Bsquare} bind def
/S11 {BL [] 0 setdash 2 copy vpt sub vpt Square fill 2 copy exch vpt sub exch vpt2 vpt Rec fill
	Bsquare} bind def
/S12 {BL [] 0 setdash 2 copy exch vpt sub exch vpt sub vpt2 vpt Rec fill Bsquare} bind def
/S13 {BL [] 0 setdash 2 copy exch vpt sub exch vpt sub vpt2 vpt Rec fill
	2 copy vpt Square fill Bsquare} bind def
/S14 {BL [] 0 setdash 2 copy exch vpt sub exch vpt sub vpt2 vpt Rec fill
	2 copy exch vpt sub exch vpt Square fill Bsquare} bind def
/S15 {BL [] 0 setdash 2 copy Bsquare fill Bsquare} bind def
/D0 {gsave translate 45 rotate 0 0 S0 stroke grestore} bind def
/D1 {gsave translate 45 rotate 0 0 S1 stroke grestore} bind def
/D2 {gsave translate 45 rotate 0 0 S2 stroke grestore} bind def
/D3 {gsave translate 45 rotate 0 0 S3 stroke grestore} bind def
/D4 {gsave translate 45 rotate 0 0 S4 stroke grestore} bind def
/D5 {gsave translate 45 rotate 0 0 S5 stroke grestore} bind def
/D6 {gsave translate 45 rotate 0 0 S6 stroke grestore} bind def
/D7 {gsave translate 45 rotate 0 0 S7 stroke grestore} bind def
/D8 {gsave translate 45 rotate 0 0 S8 stroke grestore} bind def
/D9 {gsave translate 45 rotate 0 0 S9 stroke grestore} bind def
/D10 {gsave translate 45 rotate 0 0 S10 stroke grestore} bind def
/D11 {gsave translate 45 rotate 0 0 S11 stroke grestore} bind def
/D12 {gsave translate 45 rotate 0 0 S12 stroke grestore} bind def
/D13 {gsave translate 45 rotate 0 0 S13 stroke grestore} bind def
/D14 {gsave translate 45 rotate 0 0 S14 stroke grestore} bind def
/D15 {gsave translate 45 rotate 0 0 S15 stroke grestore} bind def
/DiaE {stroke [] 0 setdash vpt add M
  hpt neg vpt neg V hpt vpt neg V
  hpt vpt V hpt neg vpt V closepath stroke} def
/BoxE {stroke [] 0 setdash exch hpt sub exch vpt add M
  0 vpt2 neg V hpt2 0 V 0 vpt2 V
  hpt2 neg 0 V closepath stroke} def
/TriUE {stroke [] 0 setdash vpt 1.12 mul add M
  hpt neg vpt -1.62 mul V
  hpt 2 mul 0 V
  hpt neg vpt 1.62 mul V closepath stroke} def
/TriDE {stroke [] 0 setdash vpt 1.12 mul sub M
  hpt neg vpt 1.62 mul V
  hpt 2 mul 0 V
  hpt neg vpt -1.62 mul V closepath stroke} def
/PentE {stroke [] 0 setdash gsave
  translate 0 hpt M 4 {72 rotate 0 hpt L} repeat
  closepath stroke grestore} def
/CircE {stroke [] 0 setdash 
  hpt 0 360 arc stroke} def
/Opaque {gsave closepath 1 setgray fill grestore 0 setgray closepath} def
/DiaW {stroke [] 0 setdash vpt add M
  hpt neg vpt neg V hpt vpt neg V
  hpt vpt V hpt neg vpt V Opaque stroke} def
/BoxW {stroke [] 0 setdash exch hpt sub exch vpt add M
  0 vpt2 neg V hpt2 0 V 0 vpt2 V
  hpt2 neg 0 V Opaque stroke} def
/TriUW {stroke [] 0 setdash vpt 1.12 mul add M
  hpt neg vpt -1.62 mul V
  hpt 2 mul 0 V
  hpt neg vpt 1.62 mul V Opaque stroke} def
/TriDW {stroke [] 0 setdash vpt 1.12 mul sub M
  hpt neg vpt 1.62 mul V
  hpt 2 mul 0 V
  hpt neg vpt -1.62 mul V Opaque stroke} def
/PentW {stroke [] 0 setdash gsave
  translate 0 hpt M 4 {72 rotate 0 hpt L} repeat
  Opaque stroke grestore} def
/CircW {stroke [] 0 setdash 
  hpt 0 360 arc Opaque stroke} def
/BoxFill {gsave Rec 1 setgray fill grestore} def
/Density {
  /Fillden exch def
  currentrgbcolor
  /ColB exch def /ColG exch def /ColR exch def
  /ColR ColR Fillden mul Fillden sub 1 add def
  /ColG ColG Fillden mul Fillden sub 1 add def
  /ColB ColB Fillden mul Fillden sub 1 add def
  ColR ColG ColB setrgbcolor} def
/BoxColFill {gsave Rec PolyFill} def
/PolyFill {gsave Density fill grestore grestore} def
/h {rlineto rlineto rlineto gsave closepath fill grestore} bind def
%
% PostScript Level 1 Pattern Fill routine for rectangles
% Usage: x y w h s a XX PatternFill
%	x,y = lower left corner of box to be filled
%	w,h = width and height of box
%	  a = angle in degrees between lines and x-axis
%	 XX = 0/1 for no/yes cross-hatch
%
/PatternFill {gsave /PFa [ 9 2 roll ] def
  PFa 0 get PFa 2 get 2 div add PFa 1 get PFa 3 get 2 div add translate
  PFa 2 get -2 div PFa 3 get -2 div PFa 2 get PFa 3 get Rec
  TransparentPatterns {} {gsave 1 setgray fill grestore} ifelse
  clip
  currentlinewidth 0.5 mul setlinewidth
  /PFs PFa 2 get dup mul PFa 3 get dup mul add sqrt def
  0 0 M PFa 5 get rotate PFs -2 div dup translate
  0 1 PFs PFa 4 get div 1 add floor cvi
	{PFa 4 get mul 0 M 0 PFs V} for
  0 PFa 6 get ne {
	0 1 PFs PFa 4 get div 1 add floor cvi
	{PFa 4 get mul 0 2 1 roll M PFs 0 V} for
 } if
  stroke grestore} def
%
/languagelevel where
 {pop languagelevel} {1} ifelse
dup 2 lt
	{/InterpretLevel1 true def
	 /InterpretLevel3 false def}
	{/InterpretLevel1 Level1 def
	 2 gt
	    {/InterpretLevel3 Level3 def}
	    {/InterpretLevel3 false def}
	 ifelse }
 ifelse
%
% PostScript level 2 pattern fill definitions
%
/Level2PatternFill {
/Tile8x8 {/PaintType 2 /PatternType 1 /TilingType 1 /BBox [0 0 8 8] /XStep 8 /YStep 8}
	bind def
/KeepColor {currentrgbcolor [/Pattern /DeviceRGB] setcolorspace} bind def
<< Tile8x8
 /PaintProc {0.5 setlinewidth pop 0 0 M 8 8 L 0 8 M 8 0 L stroke} 
>> matrix makepattern
/Pat1 exch def
<< Tile8x8
 /PaintProc {0.5 setlinewidth pop 0 0 M 8 8 L 0 8 M 8 0 L stroke
	0 4 M 4 8 L 8 4 L 4 0 L 0 4 L stroke}
>> matrix makepattern
/Pat2 exch def
<< Tile8x8
 /PaintProc {0.5 setlinewidth pop 0 0 M 0 8 L
	8 8 L 8 0 L 0 0 L fill}
>> matrix makepattern
/Pat3 exch def
<< Tile8x8
 /PaintProc {0.5 setlinewidth pop -4 8 M 8 -4 L
	0 12 M 12 0 L stroke}
>> matrix makepattern
/Pat4 exch def
<< Tile8x8
 /PaintProc {0.5 setlinewidth pop -4 0 M 8 12 L
	0 -4 M 12 8 L stroke}
>> matrix makepattern
/Pat5 exch def
<< Tile8x8
 /PaintProc {0.5 setlinewidth pop -2 8 M 4 -4 L
	0 12 M 8 -4 L 4 12 M 10 0 L stroke}
>> matrix makepattern
/Pat6 exch def
<< Tile8x8
 /PaintProc {0.5 setlinewidth pop -2 0 M 4 12 L
	0 -4 M 8 12 L 4 -4 M 10 8 L stroke}
>> matrix makepattern
/Pat7 exch def
<< Tile8x8
 /PaintProc {0.5 setlinewidth pop 8 -2 M -4 4 L
	12 0 M -4 8 L 12 4 M 0 10 L stroke}
>> matrix makepattern
/Pat8 exch def
<< Tile8x8
 /PaintProc {0.5 setlinewidth pop 0 -2 M 12 4 L
	-4 0 M 12 8 L -4 4 M 8 10 L stroke}
>> matrix makepattern
/Pat9 exch def
/Pattern1 {PatternBgnd KeepColor Pat1 setpattern} bind def
/Pattern2 {PatternBgnd KeepColor Pat2 setpattern} bind def
/Pattern3 {PatternBgnd KeepColor Pat3 setpattern} bind def
/Pattern4 {PatternBgnd KeepColor Landscape {Pat5} {Pat4} ifelse setpattern} bind def
/Pattern5 {PatternBgnd KeepColor Landscape {Pat4} {Pat5} ifelse setpattern} bind def
/Pattern6 {PatternBgnd KeepColor Landscape {Pat9} {Pat6} ifelse setpattern} bind def
/Pattern7 {PatternBgnd KeepColor Landscape {Pat8} {Pat7} ifelse setpattern} bind def
} def
%
%
%End of PostScript Level 2 code
%
/PatternBgnd {
  TransparentPatterns {} {gsave 1 setgray fill grestore} ifelse
} def
%
% Substitute for Level 2 pattern fill codes with
% grayscale if Level 2 support is not selected.
%
/Level1PatternFill {
/Pattern1 {0.250 Density} bind def
/Pattern2 {0.500 Density} bind def
/Pattern3 {0.750 Density} bind def
/Pattern4 {0.125 Density} bind def
/Pattern5 {0.375 Density} bind def
/Pattern6 {0.625 Density} bind def
/Pattern7 {0.875 Density} bind def
} def
%
% Now test for support of Level 2 code
%
Level1 {Level1PatternFill} {Level2PatternFill} ifelse
%
/Symbol-Oblique /Symbol findfont [1 0 .167 1 0 0] makefont
dup length dict begin {1 index /FID eq {pop pop} {def} ifelse} forall
currentdict end definefont pop
%
/MFshow {
   { dup 5 get 3 ge
     { 5 get 3 eq {gsave} {grestore} ifelse }
     {dup dup 0 get findfont exch 1 get scalefont setfont
     [ currentpoint ] exch dup 2 get 0 exch R dup 5 get 2 ne {dup dup 6
     get exch 4 get {textshow} {stringwidth pop 0 R} ifelse }if dup 5 get 0 eq
     {dup 3 get {2 get neg 0 exch R pop} {pop aload pop M} ifelse} {dup 5
     get 1 eq {dup 2 get exch dup 3 get exch 6 get stringwidth pop -2 div
     dup 0 R} {dup 6 get stringwidth pop -2 div 0 R 6 get
     textshow 2 index {aload pop M neg 3 -1 roll neg R pop pop} {pop pop pop
     pop aload pop M} ifelse }ifelse }ifelse }
     ifelse }
   forall} def
/Gswidth {dup type /stringtype eq {stringwidth} {pop (n) stringwidth} ifelse} def
/MFwidth {0 exch { dup 5 get 3 ge { 5 get 3 eq { 0 } { pop } ifelse }
 {dup 3 get{dup dup 0 get findfont exch 1 get scalefont setfont
     6 get Gswidth pop add} {pop} ifelse} ifelse} forall} def
/MLshow { currentpoint stroke M
  0 exch R
  Blacktext {gsave 0 setgray MFshow grestore} {MFshow} ifelse } bind def
/MRshow { currentpoint stroke M
  exch dup MFwidth neg 3 -1 roll R
  Blacktext {gsave 0 setgray MFshow grestore} {MFshow} ifelse } bind def
/MCshow { currentpoint stroke M
  exch dup MFwidth -2 div 3 -1 roll R
  Blacktext {gsave 0 setgray MFshow grestore} {MFshow} ifelse } bind def
/XYsave    { [( ) 1 2 true false 3 ()] } bind def
/XYrestore { [( ) 1 2 true false 4 ()] } bind def
Level1 SuppressPDFMark or 
{} {
/SDict 10 dict def
systemdict /pdfmark known not {
  userdict /pdfmark systemdict /cleartomark get put
} if
SDict begin [
  /Title (synth1-routing-tables-heatmap-sla-off-optimal.eps)
  /Subject (gnuplot plot)
  /Creator (gnuplot 5.0 patchlevel 3)
  /Author (rcf)
%  /Producer (gnuplot)
%  /Keywords ()
  /CreationDate (Mon Oct 31 10:54:38 2016)
  /DOCINFO pdfmark
end
} ifelse
%
% Support for boxed text - Ethan A Merritt May 2005
%
/InitTextBox { userdict /TBy2 3 -1 roll put userdict /TBx2 3 -1 roll put
           userdict /TBy1 3 -1 roll put userdict /TBx1 3 -1 roll put
	   /Boxing true def } def
/ExtendTextBox { Boxing
    { gsave dup false charpath pathbbox
      dup TBy2 gt {userdict /TBy2 3 -1 roll put} {pop} ifelse
      dup TBx2 gt {userdict /TBx2 3 -1 roll put} {pop} ifelse
      dup TBy1 lt {userdict /TBy1 3 -1 roll put} {pop} ifelse
      dup TBx1 lt {userdict /TBx1 3 -1 roll put} {pop} ifelse
      grestore } if } def
/PopTextBox { newpath TBx1 TBxmargin sub TBy1 TBymargin sub M
               TBx1 TBxmargin sub TBy2 TBymargin add L
	       TBx2 TBxmargin add TBy2 TBymargin add L
	       TBx2 TBxmargin add TBy1 TBymargin sub L closepath } def
/DrawTextBox { PopTextBox stroke /Boxing false def} def
/FillTextBox { gsave PopTextBox 1 1 1 setrgbcolor fill grestore /Boxing false def} def
0 0 0 0 InitTextBox
/TBxmargin 20 def
/TBymargin 20 def
/Boxing false def
/textshow { ExtendTextBox Gshow } def
%
% redundant definitions for compatibility with prologue.ps older than 5.0.2
/LTB {BL [] LCb DL} def
/LTb {PL [] LCb DL} def
end
%%EndProlog
%%Page: 1 1
gnudict begin
gsave
doclip
50 50 translate
0.050 0.050 scale
0 setgray
newpath
(Helvetica) findfont 200 scalefont setfont
BackgroundColor 0 lt 3 1 roll 0 lt exch 0 lt or or not {BackgroundColor C 1.000 0 0 7200.00 5040.00 BoxColFill} if
gsave % colour palette begin
/maxcolors 0 def
/HSV2RGB {  exch dup 0.0 eq {pop exch pop dup dup} % achromatic gray
  { /HSVs exch def /HSVv exch def 6.0 mul dup floor dup 3 1 roll sub
     /HSVf exch def /HSVi exch cvi def /HSVp HSVv 1.0 HSVs sub mul def
	 /HSVq HSVv 1.0 HSVs HSVf mul sub mul def 
	 /HSVt HSVv 1.0 HSVs 1.0 HSVf sub mul sub mul def
	 /HSVi HSVi 6 mod def 0 HSVi eq {HSVv HSVt HSVp}
	 {1 HSVi eq {HSVq HSVv HSVp}{2 HSVi eq {HSVp HSVv HSVt}
	 {3 HSVi eq {HSVp HSVq HSVv}{4 HSVi eq {HSVt HSVp HSVv}
	 {HSVv HSVp HSVq} ifelse} ifelse} ifelse} ifelse} ifelse
  } ifelse} def
/Constrain {
  dup 0 lt {0 exch pop}{dup 1 gt {1 exch pop} if} ifelse} def
/YIQ2RGB {
  3 copy -1.702 mul exch -1.105 mul add add Constrain 4 1 roll
  3 copy -0.647 mul exch -0.272 mul add add Constrain 5 1 roll
  0.621 mul exch -0.956 mul add add Constrain 3 1 roll } def
/CMY2RGB {  1 exch sub exch 1 exch sub 3 2 roll 1 exch sub 3 1 roll exch } def
/XYZ2RGB {  3 copy -0.9017 mul exch -0.1187 mul add exch 0.0585 mul exch add
  Constrain 4 1 roll 3 copy -0.0279 mul exch 1.999 mul add exch
  -0.9844 mul add Constrain 5 1 roll -0.2891 mul exch -0.5338 mul add
  exch 1.91 mul exch add Constrain 3 1 roll} def
/SelectSpace {ColorSpace (HSV) eq {HSV2RGB}{ColorSpace (XYZ) eq {
  XYZ2RGB}{ColorSpace (CMY) eq {CMY2RGB}{ColorSpace (YIQ) eq {YIQ2RGB}
  if} ifelse} ifelse} ifelse} def
/InterpolatedColor true def
/grayindex {/gidx 0 def
  {GrayA gidx get grayv ge {exit} if /gidx gidx 1 add def} loop} def
/dgdx {grayv GrayA gidx get sub GrayA gidx 1 sub get
  GrayA gidx get sub div} def 
/redvalue {RedA gidx get RedA gidx 1 sub get
  RedA gidx get sub dgdxval mul add} def
/greenvalue {GreenA gidx get GreenA gidx 1 sub get
  GreenA gidx get sub dgdxval mul add} def
/bluevalue {BlueA gidx get BlueA gidx 1 sub get
  BlueA gidx get sub dgdxval mul add} def
/interpolate {
  grayindex grayv GrayA gidx get sub abs 1e-5 le
    {RedA gidx get GreenA gidx get BlueA gidx get}
    {/dgdxval dgdx def redvalue greenvalue bluevalue} ifelse} def
/GrayA [0 .001 .0025 .0035 .005 .007 .009 .0115 .015 .021 .032 .05 .079 
  .1245 .1945 .3 .456 .6835 1 1 ] def
/RedA [0 .2187 .2885 .3017 .3393 .3652 .3854 .4058 .4288 .4596 .5008 .5482 
  .6011 .6587 .7204 .7857 .8545 .9266 1 1 ] def
/GreenA [0 .0005 .002 .0025 .0045 .0065 .0085 .011 .0145 .0205 .0315 .0495 
  .0785 .124 .194 .2995 .4555 .683 1 1 ] def
/BlueA [0 .0005 .002 .0025 .0045 .0065 .0085 .011 .0145 .0205 .0315 .0495 
  .0785 .124 .194 .2995 .4555 .683 1 1 ] def
/pm3dround {maxcolors 0 gt {dup 1 ge
	{pop 1} {maxcolors mul floor maxcolors 1 sub div} ifelse} if} def
/pm3dGamma 1.0 1.5 Gamma mul div def
/ColorSpace (RGB) def
Color InterpolatedColor or { % COLOUR vs. GRAY map
  InterpolatedColor { %% Interpolation vs. RGB-Formula
    /g {stroke pm3dround /grayv exch def interpolate
        SelectSpace setrgbcolor} bind def
  }{
  /g {stroke pm3dround dup cF7 Constrain exch dup cF5 Constrain exch cF15 Constrain 
       SelectSpace setrgbcolor} bind def
  } ifelse
}{
  /g {stroke pm3dround pm3dGamma exp setgray} bind def
} ifelse
1.000 UL
LTb
LCb setrgbcolor
540 4084 M
5297 0 R
stroke
420 4084 M
[ [(Helvetica) 200.0 0.0 true true 0 ( 0)]
] -66.7 MRshow
1.000 UL
LTb
LCb setrgbcolor
540 2974 M
5297 0 R
stroke
420 2974 M
[ [(Helvetica) 200.0 0.0 true true 0 ( 1)]
] -66.7 MRshow
1.000 UL
LTb
LCb setrgbcolor
540 1865 M
5297 0 R
stroke
420 1865 M
[ [(Helvetica) 200.0 0.0 true true 0 ( 2)]
] -66.7 MRshow
1.000 UL
LTb
LCb setrgbcolor
540 755 M
5297 0 R
stroke
420 755 M
[ [(Helvetica) 200.0 0.0 true true 0 ( 3)]
] -66.7 MRshow
1.000 UL
LTb
LCb setrgbcolor
981 200 M
0 63 V
0 4376 R
0 -63 V
stroke
LTb
LCb setrgbcolor
1864 200 M
0 63 V
0 4376 R
0 -63 V
stroke
LTb
LCb setrgbcolor
2747 200 M
0 63 V
0 4376 R
0 -63 V
stroke
LTb
LCb setrgbcolor
3630 200 M
0 63 V
0 4376 R
0 -63 V
stroke
LTb
LCb setrgbcolor
4513 200 M
0 63 V
0 4376 R
0 -63 V
stroke
LTb
LCb setrgbcolor
5396 200 M
0 63 V
0 4376 R
0 -63 V
stroke
LTb
LCb setrgbcolor
981 4639 M
981 200 M
stroke
981 4839 M
[ [(Helvetica) 200.0 0.0 true true 0 ( 0)]
] -66.7 MCshow
1.000 UL
LTb
LCb setrgbcolor
1864 4639 M
0 -4439 R
stroke
1864 4839 M
[ [(Helvetica) 200.0 0.0 true true 0 ( 1)]
] -66.7 MCshow
1.000 UL
LTb
LCb setrgbcolor
2747 4639 M
0 -4439 R
stroke
2747 4839 M
[ [(Helvetica) 200.0 0.0 true true 0 ( 2)]
] -66.7 MCshow
1.000 UL
LTb
LCb setrgbcolor
3630 4639 M
0 -4439 R
stroke
3630 4839 M
[ [(Helvetica) 200.0 0.0 true true 0 ( 3)]
] -66.7 MCshow
1.000 UL
LTb
LCb setrgbcolor
4513 4639 M
0 -4439 R
stroke
4513 4839 M
[ [(Helvetica) 200.0 0.0 true true 0 ( 4)]
] -66.7 MCshow
1.000 UL
LTb
LCb setrgbcolor
5396 4639 M
0 -4439 R
stroke
5396 4839 M
[ [(Helvetica) 200.0 0.0 true true 0 ( 5)]
] -66.7 MCshow
1.000 UL
LTb
LCb setrgbcolor
1.000 UL
LTB
LCb setrgbcolor
540 4639 N
540 200 L
5297 0 V
0 4439 V
-5297 0 V
Z stroke
1.000 UP
1.000 UL
LTb
LCb setrgbcolor
% Begin plot #1
5.000 UL
LTb
LT1
0.58 0.00 0.83 C /Helvetica findfont 200 scalefont setfont
/vshift -66 def
%%%%BeginImage
gsave 540 4639 N 540 200 L 5837 200 L 5837 4639 L Z clip
InterpretLevel1 {
  %% Construct a box instead of image
  LTb
  540 4639 M
  5297 0 V
  0 -4439 V
  -5297 0 V
  540 4639 L
  40 -110 R
  (PS level 2 image) Lshow
  % Read data but ignore it
  /imagebuf 32 string def
  currentfile imagebuf readstring
} {
gsave
540 4639 translate
5297 -4439 scale
%%%%BeginPalette
[ /Indexed
  /DeviceRGB 255
  <
   000000 540101 610202 690303 6f0404 740505 780606 7c0707
   800808 830909 850a0a 880b0b 8a0c0c 8d0d0d 8f0e0e 910f0f
   931010 941111 961212 981313 991414 9b1515 9c1616 9e1717
   9f1818 a01919 a21a1a a31b1b a41c1c a51d1d a61e1e a71f1f
   a82020 a92121 aa2222 ab2323 ac2424 ad2525 ae2626 af2727
   b02828 b12929 b22a2a b32b2b b32c2c b42d2d b52e2e b62f2f
   b73030 b73131 b83232 b93333 ba3434 ba3535 bb3636 bc3737
   bc3838 bd3939 be3a3a be3b3b bf3c3c c03d3d c03e3e c13f3f
   c14040 c24141 c34242 c34343 c44444 c44545 c54646 c54747
   c64848 c74949 c74a4a c84b4b c84c4c c94d4d c94e4e ca4f4f
   ca5050 cb5151 cb5252 cc5353 cc5454 cd5555 cd5656 ce5757
   ce5858 cf5959 cf5a5a d05b5b d05c5c d05d5d d15e5e d15f5f
   d26060 d26161 d36262 d36363 d36464 d46565 d46666 d56767
   d56868 d66969 d66a6a d66b6b d76c6c d76d6d d86e6e d86f6f
   d87070 d97171 d97272 d97373 da7474 da7575 db7676 db7777
   db7878 dc7979 dc7a7a dc7b7b dd7c7c dd7d7d dd7e7e de7f7f
   de8080 df8181 df8282 df8383 e08484 e08585 e08686 e18787
   e18888 e18989 e28a8a e28b8b e28c8c e38d8d e38e8e e38f8f
   e39090 e49191 e49292 e49393 e59494 e59595 e59696 e69797
   e69898 e69999 e79a9a e79b9b e79c9c e79d9d e89e9e e89f9f
   e8a0a0 e9a1a1 e9a2a2 e9a3a3 e9a4a4 eaa5a5 eaa6a6 eaa7a7
   eba8a8 eba9a9 ebaaaa ebabab ecacac ecadad ecaeae edafaf
   edb0b0 edb1b1 edb2b2 eeb3b3 eeb4b4 eeb5b5 eeb6b6 efb7b7
   efb8b8 efb9b9 efbaba f0bbbb f0bcbc f0bdbd f0bebe f1bfbf
   f1c0c0 f1c1c1 f1c2c2 f2c3c3 f2c4c4 f2c5c5 f2c6c6 f3c7c7
   f3c8c8 f3c9c9 f3caca f4cbcb f4cccc f4cdcd f4cece f5cfcf
   f5d0d0 f5d1d1 f5d2d2 f6d3d3 f6d4d4 f6d5d5 f6d6d6 f6d7d7
   f7d8d8 f7d9d9 f7dada f7dbdb f8dcdc f8dddd f8dede f8dfdf
   f8e0e0 f9e1e1 f9e2e2 f9e3e3 f9e4e4 fae5e5 fae6e6 fae7e7
   fae8e8 fae9e9 fbeaea fbebeb fbecec fbeded fceeee fcefef
   fcf0f0 fcf1f1 fcf2f2 fdf3f3 fdf4f4 fdf5f5 fdf6f6 fdf7f7
   fef8f8 fef9f9 fefafa fefbfb fefcfc fffdfd fffefe ffffff
  >
] setcolorspace
%%%%EndPalette
<<
  /ImageType 1
  /Width 6
  /Height 4
  /BitsPerComponent 8
  /ImageMatrix [ 6 0 0 4 0 0 ]
  /Decode [ 0 255 ]
  /DataSource currentfile /ASCII85Decode filter
  /MultipleDataSources false
  /Interpolate false
>>
image
} ifelse
QBnA&V:([+V+Z'NQ?[Y!QF,)I['[3X~>
InterpretLevel1 not {
  grestore
} if
grestore
%%%%EndImage
% End plot #1
% Begin plot #2
5.000 UL
LTb
LT1
LCb setrgbcolor
/Helvetica findfont 200 scalefont setfont
1.000 UP
LCb setrgbcolor
981 4084 M
[ [(Helvetica) 200.0 0.0 true true 0 (7)]
] -66.7 MCshow
LCb setrgbcolor
1864 4084 M
[ [(Helvetica) 200.0 0.0 true true 0 (7)]
] -66.7 MCshow
LCb setrgbcolor
2747 4084 M
[ [(Helvetica) 200.0 0.0 true true 0 (6)]
] -66.7 MCshow
LCb setrgbcolor
3630 4084 M
[ [(Helvetica) 200.0 0.0 true true 0 (8)]
] -66.7 MCshow
LCb setrgbcolor
4513 4084 M
[ [(Helvetica) 200.0 0.0 true true 0 (6)]
] -66.7 MCshow
LCb setrgbcolor
5396 4084 M
[ [(Helvetica) 200.0 0.0 true true 0 (3)]
] -66.7 MCshow
LCb setrgbcolor
981 2974 M
[ [(Helvetica) 200.0 0.0 true true 0 (7)]
] -66.7 MCshow
LCb setrgbcolor
1864 2974 M
[ [(Helvetica) 200.0 0.0 true true 0 (6)]
] -66.7 MCshow
LCb setrgbcolor
2747 2974 M
[ [(Helvetica) 200.0 0.0 true true 0 (6)]
] -66.7 MCshow
LCb setrgbcolor
3630 2974 M
[ [(Helvetica) 200.0 0.0 true true 0 (12)]
] -66.7 MCshow
LCb setrgbcolor
4513 2974 M
[ [(Helvetica) 200.0 0.0 true true 0 (9)]
] -66.7 MCshow
LCb setrgbcolor
5396 2974 M
[ [(Helvetica) 200.0 0.0 true true 0 (4)]
] -66.7 MCshow
LCb setrgbcolor
981 1865 M
[ [(Helvetica) 200.0 0.0 true true 0 (7)]
] -66.7 MCshow
LCb setrgbcolor
1864 1865 M
[ [(Helvetica) 200.0 0.0 true true 0 (9)]
] -66.7 MCshow
LCb setrgbcolor
2747 1865 M
[ [(Helvetica) 200.0 0.0 true true 0 (9)]
] -66.7 MCshow
LCb setrgbcolor
3630 1865 M
[ [(Helvetica) 200.0 0.0 true true 0 (9)]
] -66.7 MCshow
LCb setrgbcolor
4513 1865 M
[ [(Helvetica) 200.0 0.0 true true 0 (7)]
] -66.7 MCshow
LCb setrgbcolor
5396 1865 M
[ [(Helvetica) 200.0 0.0 true true 0 (5)]
] -66.7 MCshow
LCb setrgbcolor
981 755 M
[ [(Helvetica) 200.0 0.0 true true 0 (3)]
] -66.7 MCshow
LCb setrgbcolor
1864 755 M
[ [(Helvetica) 200.0 0.0 true true 0 (5)]
] -66.7 MCshow
LCb setrgbcolor
2747 755 M
[ [(Helvetica) 200.0 0.0 true true 0 (5)]
] -66.7 MCshow
LCb setrgbcolor
3630 755 M
[ [(Helvetica) 200.0 0.0 true true 0 (5)]
] -66.7 MCshow
LCb setrgbcolor
4513 755 M
[ [(Helvetica) 200.0 0.0 true true 0 (5)]
] -66.7 MCshow
LCb setrgbcolor
5396 755 M
[ [(Helvetica) 200.0 0.0 true true 0 (4)]
] -66.7 MCshow
% End plot #2
2.000 UL
LTb
LCb setrgbcolor
1.000 UL
LTB
LCb setrgbcolor
540 4639 N
540 200 L
5297 0 V
0 4439 V
-5297 0 V
Z stroke
stroke gsave	%% draw gray scale smooth box
maxcolors 0 gt {/imax maxcolors def} {/imax 1024 def} ifelse
5969 200 translate 264 4439 scale 0 setlinewidth
/ystep 1 imax div def /y0 0 def /ii 0 def
{ 0.99999 y0 sub g 0 y0 N 1 0 V 0 ystep V -1 0 f
/y0 y0 ystep add def /ii ii 1 add def
ii imax ge {exit} if } loop
grestore 0 setgray
1.000 UL
LTb
LCb setrgbcolor
5969 200 N
264 0 V
0 4439 V
-264 0 V
0 -4439 V
Z stroke
1.000 UL
LTb
LCb setrgbcolor
1.000 UL
LTb
LCb setrgbcolor
6233 200 M
-63 0 V
stroke
6353 200 M
[ [(Helvetica) 200.0 0.0 true true 0 ( 0)]
] -66.7 MLshow
1.000 UL
LTb
LCb setrgbcolor
5969 200 M
63 0 V
201 522 R
-63 0 V
stroke
6353 722 M
[ [(Helvetica) 200.0 0.0 true true 0 ( 2)]
] -66.7 MLshow
1.000 UL
LTb
LCb setrgbcolor
5969 722 M
63 0 V
201 522 R
-63 0 V
stroke
6353 1244 M
[ [(Helvetica) 200.0 0.0 true true 0 ( 4)]
] -66.7 MLshow
1.000 UL
LTb
LCb setrgbcolor
5969 1244 M
63 0 V
201 522 R
-63 0 V
stroke
6353 1766 M
[ [(Helvetica) 200.0 0.0 true true 0 ( 6)]
] -66.7 MLshow
1.000 UL
LTb
LCb setrgbcolor
5969 1766 M
63 0 V
201 522 R
-63 0 V
stroke
6353 2288 M
[ [(Helvetica) 200.0 0.0 true true 0 ( 8)]
] -66.7 MLshow
1.000 UL
LTb
LCb setrgbcolor
5969 2288 M
63 0 V
201 523 R
-63 0 V
stroke
6353 2811 M
[ [(Helvetica) 200.0 0.0 true true 0 ( 10)]
] -66.7 MLshow
1.000 UL
LTb
LCb setrgbcolor
5969 2811 M
63 0 V
201 522 R
-63 0 V
stroke
6353 3333 M
[ [(Helvetica) 200.0 0.0 true true 0 ( 12)]
] -66.7 MLshow
1.000 UL
LTb
LCb setrgbcolor
5969 3333 M
63 0 V
201 522 R
-63 0 V
stroke
6353 3855 M
[ [(Helvetica) 200.0 0.0 true true 0 ( 14)]
] -66.7 MLshow
1.000 UL
LTb
LCb setrgbcolor
5969 3855 M
63 0 V
201 522 R
-63 0 V
stroke
6353 4377 M
[ [(Helvetica) 200.0 0.0 true true 0 ( 16)]
] -66.7 MLshow
1.000 UL
LTb
LCb setrgbcolor
5969 4377 M
63 0 V
stroke
LCb setrgbcolor
6773 2419 M
currentpoint gsave translate -270 rotate 0 0 moveto
[ [(Helvetica) 300.0 0.0 true true 0 (Routing Entries)]
] -100.0 MCshow
grestore
LTb
1.000 UP
1.000 UL
LTb
LCb setrgbcolor
grestore % colour palette end
stroke
grestore
end
showpage
%%Trailer
%%DocumentFonts: Helvetica
